# -*- coding: utf-8 -*-
"""SyneNB.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12z3irQJEHWRDioByLTc7G9KoDyRw6Ozy
"""

!pip install mne

import seaborn as sns
import mne 
import numpy as np
import matplotlib.pyplot as plt
import math 
import mne
import os
import warnings
import copy 
import pandas as pd
import scipy
warnings.filterwarnings('ignore')

from scipy.io import loadmat
from scipy.signal import butter, lfilter
from numpy import sqrt
from collections import OrderedDict
from multiprocessing import Process
from mne.datasets import sample
from mne.decoding import UnsupervisedSpatialFilter
from mne.io import read_raw_bdf
from mne.io import read_raw_edf
from sklearn.decomposition import PCA, FastICA
from time import time, strftime, gmtime
from glob import glob
from collections import OrderedDict
from scipy.signal import butter, sosfilt, sosfreqz
from scipy import signal

# bandpass filter function object
# butterworth IIR filter of order 10  
def butter_bandpass(lowcut, highcut, fs, order=10):
        nyq = 0.5 * fs
        low = lowcut / nyq
        high = highcut / nyq
        sos = butter(order, [low, high], analog=False, btype='band', output='sos')
        return sos

def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
        sos = butter_bandpass(lowcut, highcut, fs, order=order)
        y = sosfilt(sos, data)
        return

# take csv file from the open_BCI and convert to a raw file 
def load_csv_as_raw(filename, sfreq, ch_ind, stim_ind, aux_ind=None,
                              replace_ch_names=None, verbose=1):
    """"""
    ch_ind = copy.deepcopy(ch_ind)
    n_eeg = len(ch_ind)
    if aux_ind is not None:
        n_aux = len(aux_ind)
        n_channel = n_eeg + n_aux
        ch_ind += aux_ind
    else:
        n_channel = n_eeg
        n_aux = 0

    raw = []
    for fn in filename:
        # Read the file
        data = pd.read_csv(fn, index_col=0)

        # Channel names and types
        ch_names = list(data.columns)[0:n_channel] + ['stim']
        print(ch_names)
        ch_types = ['eeg'] * n_eeg + ['misc'] * n_aux + ['stim']

        if replace_ch_names is not None:
            ch_names = [c if c not in replace_ch_names.keys()
                        else replace_ch_names[c] for c in ch_names]

        
        data = data.values[:,:].T
                           #ch_ind + [stim_ind]].T
        data[:-1] = data[:-1].astype(int) * 1e-6

        # create MNE object
        info = create_info(ch_names=ch_names, ch_types=ch_types, sfreq=sfreq,verbose=1)
        raw.append(RawArray(data=data, info=info, verbose=1))

    raws = concatenate_raws(raw, verbose=verbose)
    montage = make_standard_montage('standard_1005')
    raws.set_montage(montage)

    return raws

# take csv file from the open_BCI and convert to a raw file 
def load_data(csvfile, replace_ch_names=None, verbose=1, site='local'):
    """Load CSV files from the /data directory into a Raw object.
    Args:
        data_dir (str): directory inside /data that contains the
            CSV files to load, e.g., 'auditory/P300'
    Keyword Args:
        subject_id (int or str): subject number. If 'all', load all
            subjects.
        session_nb (int or str): session number. If 'all', load all
            sessions.
        replace_ch_names (dict or None): dictionary containing a mapping to
            rename channels. Useful when an external electrode was used.
    Returns:
        (mne.io.array.array.RawArray): loaded EEG
    """

    data_path = os.path.join(csvfile)
    fnames = glob(data_path)
    print(data_path)

    sfreq = 250
    ch_ind = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    stim_ind = 19

    return load_csv_as_raw(
        filename=fnames,
        sfreq=sfreq,
        ch_ind=ch_ind,
        stim_ind=stim_ind,
        replace_ch_names=replace_ch_names,
        verbose=verbose
    )

# takes the average of an array of coherence values 
# only takes the average of coherence values for the frequencies values in the cutoff range 
# this cutoff range changes for each of the brain waves (alpha, delta, theta, beta)
def Average_between_channels(Cxy,frequencies):
  Cxy_bandArray = []
  # band = raw.filter(lowerCut, higherCut, method = 'iir')
  for i in range(0, frequencies.size):
    if ((frequencies[i] >= 8) and (frequencies[i] <= 12)):
      Cxy_bandArray.append(Cxy[i])
      
    return np.array(Cxy_bandArray)

"""Importing Text file from OpenBCI"""

raw = read_raw_edf('/content/bdf_file.bdf', preload = True, stim_channel = 'auto', verbose = False, exclude = ['Accel X', 'Accel Y', 'Accel Z']); 
# read a bdf file from the OpenBCI and then convert to a raw object 
# this raw object will be used to analyze the coherence values and frequency responses of each of the bands after filtering 
[frequencies,Cxy] = scipy.signal.coherence(raw._data[0], raw._data[1], 125)

# below is testing code to evaluate sample coherence values and coherence means 
[frequencies,cxy] = scipy.signal.coherence(raw._data[0], raw._data[1],125)
# take the array of coherence values that were calculated 
# and takes the average for each of the brain wave bands 
totalcxy = 0;
numcxy = 0;
for i in range(0, len(cxy)):
  if ((frequencies[i] >= 8) and (frequencies[i] <= 12)):
    totalcxy += cxy[i]
    numcxy += 1
meancxy = totalcxy/numcxy;

# below is the actual function definition of the above code after evaluating that it worked
# calculate the coherence metric between all pairs of electrodes 
def avg_coherence(raw):
  e1 = 0
  e2 = 1
  cxyavgs = []
  while e1 < 16:
    while e2 < 16:
      # use signal.coherence to calculate the coherence between the electrodes for each of the frequencies and returns an array  
      [frequencies,cxy] = scipy.signal.coherence(raw._data[e1], raw._data[e2],125)
      # take the array of coherence values that were calculated 
      # and takes the average for each of the brain wave bands 
      totalcxy = 0;
      numcxy = 0;
      for i in range(0, len(cxy)):
        if ((frequencies[i] >= 8) and (frequencies[i] <= 12)):
          totalcxy += cxy[i]
          numcxy += 1
      meancxy = totalcxy/numcxy;
      cxyavgs.append(meancxy)
      # increment both electrodes by 1 

      e2 += 1
    e1 += 1
    e2 = e1 + 1
  cxyavgs = np.array(cxyavgs)
  return np.average(cxyavgs)

print(avg_coherence(raw))

totalpower=0

for i in range(0,15):
  freqs, psd = signal.welch(raw._data, 62.5, nperseg=62.5*4)

  low, high = 4, 8

  # Find intersecting values in frequency vector
  idx_theta = np.logical_and(freqs >= low, freqs <= high)
  singlepsd = psd[i];

  from scipy.integrate import simps
  # Frequency resolution
  freq_res = freqs[1] - freqs[0]  # = 1 / 4 = 0.25

  # Compute the absolute power by approximating the area under the curve
  theta_power = simps(singlepsd[idx_theta], dx=freq_res)
  totalpower += theta_power
avgthetapower = totalpower/15
print(avgthetapower)

raw

# alpha band 
alpha_band = butter_bandpass_filter(raw._data, 8, 12, 200, order = 10)

# beta band 
beta_band = butter_bandpass_filter(raw._data, 13, 30, 200, order =10)

# theta band 
theta_band = butter_bandpass_filter(raw._data, 4, 8, 200, order =10)

# delta band 
delta_band = butter_bandpass_filter(raw._data, 1, 4, 200, order =10)

# filter each of the important brain waves using a 10th order Butterworth IIR bandpass filter
# the first two parameters correlate to the start and end frequency cutoffs for each of the brain wave bands
alpha = raw.filter(8, 12, method = 'iir')
beta = raw.filter(13, 30, method = 'iir')
theta = raw.filter(4, 8, method = 'iir')
delta = raw.filter(1, 4, method = 'iir')

alpha.info

alpha.plot()

beta.plot()

theta.plot()

delta.plot()